<?php

namespace Phnx\Anthropic\DataTransferObjects;

use Illuminate\Http\Client\Response;

final class ChatResponseData
{

    /**
     * Unique object identifier.
     *
     * The format and length of IDs may change over time.
     *
     * @var string $id
     */
    public string $id;

    /**
     * Object type.
     *
     * For Messages, this is always "message".
     *
     * Available options: message
     *
     * @var string $type
     */
    public string $type;

    /**
     * Conversational role of the generated message.
     *
     * This will always be "assistant".
     *
     * Available options: assistant
     *
     * @var string $role
     */
    public string $role;

    /**
     * Content generated by the model.
     *
     * This is an array of content blocks, each of which has a type that determines its shape.
     *
     * Example:
     *
     * [{"type": "text", "text": "Hi, I'm Claude."}]
     * If the request input messages ended with an assistant turn, then the response content will continue directly from that last turn. You can use this to constrain the model's output.
     *
     * For example, if the input messages were:
     *
     * [
     *     {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
     *     {"role": "assistant", "content": "The best answer is ("}
     * ]
     * Then the response content might be:
     *
     * [{"type": "text", "text": "B)"}]
     *
     * @var ContentData[] $content
     */
    public array $content;

    /**
     * The first text block in the content array.
     *
     * @var string $response
     */
    public string $response;

    /**
     * The model that handled the request.
     *
     * @var string $model
     */
    public string $model;

    /**
     * The reason that we stopped.
     *
     * This may be one of the following values:
     *
     *     - "end_turn": the model reached a natural stopping point
     *     - "max_tokens": we exceeded the requested max_tokens or the model's maximum
     *     - "stop_sequence": one of your provided custom stop_sequences was generated
     *     - "tool_use": the model invoked one or more tools
     *
     * In non-streaming mode this value is always non-null. In streaming mode, it is null in the message_start event and non-null otherwise.
     *
     * Available options: end_turn, max_tokens, stop_sequence, tool_use
     *
     * @var string|null $stopReason
     */
    public ?string $stopReason;

    /**
     * Which custom stop sequence was generated, if any.
     *
     * This value will be a non-null string if one of your custom stop sequences was generated.
     *
     * @var string|null $stopSequence
     */
    public ?string $stopSequence;

    /**
     * Billing and rate-limit usage.
     *
     * Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost to our systems.
     *
     * Under the hood, the API transforms requests into a format suitable for the model.
     * The model's output then goes through a parsing stage before becoming an API response.
     * As a result, the token counts in usage will not match one-to-one with the exact visible content of an API request or response.
     *
     * For example, output_tokens will be non-zero, even for an empty string response from Claude.
     *
     * @var array $usage
     */
    public array $usage;

    /**
     * Shorthand for usage.input_tokens.
     *
     * @var float|null $inputTokens
     */
    public ?float $inputTokens;

    /**
     * Shorthand for usage.output_tokens.
     *
     * @var float|null $outputTokens
     */
    public ?float $outputTokens;

    /**
     * Rate limiter information that is returned with the response headers.
     * These include:
     *
     *      - "request_limit": The maximum number of requests you can make in a given time period
     *      - "remaining_requests": The number of requests you have left in the current time period
     *      - "requests_reset_at": The time at which the request limit will reset
     *      - "token_limit": The maximum number of tokens you can use in a given time period
     *      - "remaining_tokens": The number of tokens you have left in the current time period
     *      - "tokens_reset_at": The time at which the token limit will reset
     *
     * @var array|mixed|null
     */
    public ?array $rateLimiter;

    private function __construct(array $data)
    {
        $this->id = data_get($data, 'id');
        $this->type = data_get($data, 'type');
        $this->role = data_get($data, 'role');
        $this->content = data_get($data, 'content');
        $this->response = data_get($data, 'content.0.text');
        $this->model = data_get($data, 'model');
        $this->stopReason = data_get($data, 'stop_reason');
        $this->stopSequence = data_get($data, 'stop_sequence');
        $this->usage = data_get($data, 'usage');
        $this->inputTokens = data_get($data, 'usage.input_tokens');
        $this->outputTokens = data_get($data, 'usage.output_tokens');
        $this->rateLimiter = data_get($data, 'rate_limiter');
    }

    public static function fromArray(array $data): self
    {
        if (! $data) {
            throw new \InvalidArgumentException('The data array cannot be empty');
        }

        return new self($data);
    }

    public static function fromResponse(Response $response): self
    {
        $data = [
            ...$response->json(),
            'rate_limiter' => [
                'request_limit' => (int) $response->header('anthropic-ratelimit-requests-limit'),
                'remaining_requests' => (int) $response->header('anthropic-ratelimit-requests-remaining'),
                'requests_reset_at' => strtotime($response->header('anthropic-ratelimit-requests-reset')),
                'token_limit' => (float) $response->header('anthropic-ratelimit-tokens-limit'),
                'remaining_tokens' => (float) $response->header('anthropic-ratelimit-tokens-remaining'),
                'tokens_reset_at' => strtotime($response->header('anthropic-ratelimit-tokens-reset')),
            ],
        ];

        return self::fromArray($data);
    }
}
